
import java_cup.runtime.*;
import java.util.*;
/*
 * Tutorial T8
 * 19-1023, Yahia El Gamal
 * 19-2162, Adam Ghanem
 */

parser code {:
    /* this part is included in the parser class */
    static String desc = "";
    public static void describe(String s){
      desc = s + "\n" + desc;
      /*desc += s + "\n";*/
    }
    public static void main (String args[]) throws Exception{
        new parser(new Lexer(System.in)).parse();
    }
:}

/* Terminals (tokens returned by the scanner). */
terminal RETURN,BREAK,TRUE,FALSE,NEW,SYSOUT,LALA,LOLO,IF,WHILE,FOR,TYPE,MODIF,CLASS,ST,CH,NM,DO,LP,RP,AA,MM,PP,GE,NE,LE,EQ,LO,LN,LS,RS,LC,RC,AO,PO,MO,MB,DB,SM,COMMA,LT,RT,LA,KW,ID,UNDEFINED;


/* Non-terminals */
nonterminal Boolean program; 
nonterminal String statement, class_decl, class_body_decls, class_body_decl;
nonterminal String type_args, type_arg;
nonterminal String block, block_statements, block_statement;

nonterminal String semi_column_statement, if_block, while_block, for_block;
nonterminal String left_hand_side, expression;
nonterminal String type_cast, initiate, array;
nonterminal String operation, operations, operator, atom, atoms;
nonterminal String obj;




/* The grammar */


program ::= CLASS ID:name class_decl:desc
              {:RESULT = true; parser.describe("declaring class " + name + "\n" + desc);:}
              | error
              {:RESULT = false; parser.describe("not cool bro");:};


class_decl ::= LC class_body_decls:desc RC {:RESULT = desc + "\n";:};
class_body_decls ::= class_body_decl:desc {:RESULT = desc + "\n";:}
              | class_body_decls:desc1 class_body_decl:desc2 {:RESULT = desc1 + "\n" + desc2 + "\n";:};

class_body_decl ::= MODIF MODIF TYPE:ret_type ID:name LP type_args:args RP block:block_desc 
                    {:RESULT = ("declaring method  " + name + " returns " + ret_type + "\n" + args + "{\n" + block_desc + "}" ); :}
                    | MODIF MODIF TYPE:ret_type ID:name LP RP block:block_desc
                    {:RESULT = ("declaring method  " + name + " returns " + ret_type + "{\n" + block_desc + "}" ); :}
                    ; 


type_arg ::= TYPE:type ID:name {:RESULT = "\t argument " + name +  " of type " + type + "\n";:};
type_args ::= type_arg:desc {:RESULT = desc;:}
            | type_args:desc1 COMMA type_arg:desc2 {:RESULT = desc1 + desc2;:};

block ::= LC block_statements:desc RC  {:RESULT = desc + "\n";:}
          | LC RC {:RESULT = "empty block\n";:};

block_statement ::= semi_column_statement:desc SM  {:RESULT = desc;:}
                | if_block:desc {:RESULT = desc;:}
                | while_block:desc {:RESULT = desc;:}
                | for_block:desc {:RESULT = desc;:};

block_statements ::= block_statement:desc  {:RESULT = desc;:}
                | block_statements:desc1 block_statement:desc2 {:RESULT = desc1 + "\n" + desc2 + "\n";:};

left_hand_side ::= TYPE:type AA ID:name {:RESULT = "array of type " + type + " with name " + name ;:}
                  | ID:name LS operation:op RS {:RESULT = "element " + op + " of array " + name;:}
                  | TYPE:type ID:name {:RESULT = "initialization of variable " + name + " of type " + type;:}
                  | ID:name {:RESULT = "varible " + name;:};
semi_column_statement ::= left_hand_side:left AO expression:val  {:RESULT = "assigning " + left + " to (" + val + ")" ;:}
                        | SYSOUT LP expression:exp RP  {:RESULT = "printing (" + exp + ")";:}
                        | SYSOUT LP RP {:RESULT = "printing empty line";:}
                        | BREAK {:RESULT = "stop looping";:}
                        | RETURN expression:exp {:RESULT = "RETURN " + exp;:};

if_block ::= IF LP expression:exp RP block:bl_desc {:RESULT = "if (" + exp + ") do {\n "  + bl_desc + "}";:};
while_block ::= WHILE LP expression:exp RP block:bl_desc {:RESULT = "repeat while (" + exp + "){\n" + bl_desc + "}";:};
for_block ::= FOR LP semi_column_statement:desc1 SM expression:desc2 SM expression:desc3 RP block:bl_desc 
            {:RESULT = "starting with " + desc1 + " with update of " + desc3 + " repeat while ( " + desc2 +  ") {\n" + bl_desc + "}" ;:};
expression ::= type_cast:desc {:RESULT = desc;:}
              | array:desc {:RESULT = desc;:}
              | operations:desc {:RESULT = desc;:};

type_cast ::= LP TYPE:to_type RP operations:op {:RESULT = "typecasting (" + op + ") to " + to_type;:};
array ::= LC atoms:desc RC  {:RESULT = "{" + desc + "}";:}
        | LC RC {:RESULT = "empty array";:}
        | NEW TYPE:type LS operations:op RS {:RESULT = "new array of type " + type + " and length " + op;:};
operator ::= PO  {:RESULT = "+";:}
           | MO {:RESULT = "-";:}
           | MB {:RESULT = "*";:}
           | DB {:RESULT = "/";:}
           | LALA {:RESULT = "&&";:}
           | LOLO {:RESULT = "||";:}
           | GE {:RESULT = ">=";:}
           | RT {:RESULT = ">";:}
           | LT {:RESULT = "<";:}
           | NE {:RESULT = "!=";:}
           | LE {:RESULT = "<=";:}
           | EQ {:RESULT = "==";:}; 

operation ::= atom:desc {:RESULT = desc;:} ;
operations ::= operation:desc {:RESULT = desc;:}
            | operations:desc1 operator:op operation:desc2 {:RESULT = desc1 + " " + op + " " + desc2;:}
            | LP operations:desc RP {:RESULT = desc;:};

atoms ::= atoms:desc1 COMMA atom:desc2 {:RESULT = desc1 + "," + desc2;:} | atom:desc {:RESULT = desc;:};
atom ::= MO obj:desc  {:RESULT = "-" + desc;:}
        | LN obj:desc {:RESULT = "!" + desc;:}
        | obj:desc {:RESULT = desc;:}
        | obj:desc PP {:RESULT = "using " + desc + " then incrementing by 1";:}
        | obj:desc MM  {:RESULT = "using " + desc + "then decremnting by 1";:}
        | obj:desc LS expression:exp RS {:RESULT = "element " + exp + " of array " + desc;:};

obj ::= ID:desc {:RESULT = desc+ "";:}
| NM:desc {:RESULT = desc+"";:}
| ST:desc {:RESULT = desc+"";:}
| CH:desc {:RESULT = desc+"";:}
| TRUE:desc {:RESULT = desc+"";:}
| FALSE:desc {:RESULT = desc+"";:}
| ID:desc1 DO ID:desc2 {:RESULT = desc1 + "." + desc2;:}; 
