
import java_cup.runtime.*;
import java.util.*;
/*
 * Tutorial T8
 * 19-1023, Yahia El Gamal
 * 19-2162, Adam Ghanem
 */

parser code {:
    /* this part is included in the parser class */
    static String desc = "";
    public static void describe(String s){
      desc = s + "\n" + desc;
      /*desc += s + "\n";*/
    }
    public static void main (String args[]) throws Exception{
        new parser(new Lexer(System.in)).parse();
    }
:}

/* Terminals (tokens returned by the scanner). */
terminal RETURN,BREAK,TRUE,FALSE,NEW,SYSOUT,LALA,LOLO,IF,WHILE,FOR,TYPE,MODIF,CLASS,ST,CH,NM,DO,LP,RP,AA,MM,PP,GE,NE,LE,EQ,LO,LN,LS,RS,LC,RC,AO,PO,MO,MB,DB,SM,COMMA,LT,RT,LA,KW,ID,UNDEFINED;


/* Non-terminals */
nonterminal Boolean program; 
nonterminal String statement, class_decl, class_body_decls, class_body_decl;
nonterminal String type_args, type_arg;
nonterminal String block, block_statements, block_statement;

nonterminal String semi_column_statement, if_block, while_block, for_block;
nonterminal String left_hand_side, expression;
nonterminal String type_cast, initiate, array;
nonterminal String operation, operations, operator, atom, atoms;
nonterminal String object;




/* The grammar */


program ::= CLASS ID:name class_decl:desc
              {:RESULT = true; parser.describe("declaring class " + name + "\n" + desc);:}
              | error
              {:RESULT = false; parser.describe("not cool bro");:};


class_decl ::= LC class_body_decls:desc RC {:RESULT = desc + "\n";:};
class_body_decls ::= class_body_decl:desc {:RESULT = desc + "\n";:}
              | class_body_decls:desc1 class_body_decl:desc2 {:RESULT = desc1 + desc2 + "\n";:};

class_body_decl ::= MODIF MODIF TYPE:ret_type ID:name LP type_args:args RP block:block_desc 
                    {:RESULT = ("declaring method  " + name + " returns " + ret_type + "\n" + args + "\n" + block_desc ); :}
                    | MODIF MODIF TYPE:ret_type ID:name LP RP block
                    {:RESULT = ("declaring method  " + name + " returns " + ret_type + "\n"); :}
                    ; 


type_arg ::= TYPE:type ID:name {:RESULT = "\t argument " + name +  " of type " + type + "\n";:};
type_args ::= type_arg:desc {:RESULT = desc;:}
            | type_args:desc1 COMMA type_arg:desc2 {:RESULT = desc1 + desc2;:};

block ::= LC block_statements RC | LC RC;
block_statement ::= semi_column_statement SM | if_block | while_block | for_block;
block_statements ::= block_statement | block_statements block_statement;

left_hand_side ::= TYPE AA ID 
                  | ID LS operation RS 
                  | TYPE:type ID:name
                  {: RESULT = "var " + name + " of type " + type;:}
                  | ID;
semi_column_statement ::= left_hand_side:left AO expression:val  {:RESULT = "assigning " + left + " to " ;:}
                        | SYSOUT LP expression RP 
                        | SYSOUT LP RP 
                        | BREAK
                        | RETURN expression; 

if_block ::= IF LP expression RP block;
while_block ::= WHILE LP expression RP block;
for_block ::= FOR LP semi_column_statement SM expression SM expression RP block;
expression ::= type_cast | array | operations;

type_cast ::= LP TYPE RP operations;
array ::= LC atoms RC | LC RC | NEW TYPE LS operations RS;
operator ::= PO | MO | MB | DB | LALA | LOLO | GE | RT | LT | NE | LE | EQ; /* lala and lolo are && || */

operation ::= atom;
operations ::= operation | operations operator operation | LP operations RP;

atoms ::= atoms COMMA atom | atom;
atom ::= MO object | LN object | object | object PP | object MM  | object LS expression RS; // - or !  
object ::= ID | NM | ST | CH | TRUE | FALSE | ID DO ID; 
